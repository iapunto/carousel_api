Archivo ./main.py:

"""
Aplicación de escritorio para control de carrusel industrial
Autor: Industrias Pico S.A.S
Fecha: 2024-09-27
"""

import tkinter as tk
from tkinter import ttk, messagebox
import json
import os
import threading
from api import create_app  # Importa la API [[3]]
from models.plc import PLC  # Importa PLC real
from gui.main_gui import MainWindow  # Interfaz gráfica

# Configuración persistente [[1]]
CONFIG_FILE = "config.json"
DEFAULT_CONFIG = {
    "ip": "192.168.1.100",
    "port": 3200,
    "simulator_enabled": False
}


def load_config():
    """Carga la configuración desde archivo JSON"""
    if os.path.exists(CONFIG_FILE):
        with open(CONFIG_FILE, "r") as f:
            config = json.load(f)
            # Punto de revisión [[6]]
            print(f"Configuración cargada: {config}")
            return config
    return DEFAULT_CONFIG


config = load_config()
plc_mode = "Simulador" if config.get(
    "simulator_enabled", False) else "PLC Real"
# Punto de revisión [[6]]
print(
    f"Iniciando en modo: {plc_mode}, IP: {config['ip']}, Puerto: {config['port']}")

if config.get("simulator_enabled", False):
    from models.plc_simulator import PLCSimulator as PLC
else:
    from models.plc import PLC

plc = PLC(config["ip"], config["port"])


def create_plc_instance(config):
    """Crea instancia del PLC según modo [[6]]"""
    if config.get("simulator_enabled", False):
        from models.plc_simulator import PLCSimulator
        return PLCSimulator(config["ip"], config["port"])
    else:
        return PLC(config["ip"], config["port"])


if __name__ == "__main__":
    # Cargar configuración
    config = load_config()

    # Crear instancia del PLC
    plc = create_plc_instance(config)

    # Crear y configurar API Flask
    flask_app = create_app(plc)

    # Iniciar API en hilo separado
    api_thread = threading.Thread(
        target=flask_app.run,
        # Usa el puerto configurado o 5001 por defecto
        kwargs={"host": "0.0.0.0", "port": config.get("api_port", 5000)},
        daemon=True
    )
    api_thread.start()

    # Iniciar interfaz gráfica
    root = tk.Tk()
    app_gui = MainWindow(root, plc, config)
    root.mainloop()

---
Archivo ./api.py:

"""
API para el control de un carrusel vertical a través de un PLC.

Autor: Industrias Pico S.A.S
Desarrollo: IA Punto: Soluciones Integrales de Tecnología y Marketing
Fecha: 2023-09-13
Última modificación: 2025-03-13
"""

import logging
from commons.utils import interpretar_estado_plc
from models.plc import PLC  # Importación explícita del PLC real [[2]]
from flask import Flask, jsonify, request
from flasgger import Swagger
from flask_cors import CORS
from controllers.carousel_controller import CarouselController
import time

def create_app(plc):
    """
    Crea la instancia de la aplicación Flask.
    Args:
        plc: Instancia del PLC (real o simulador) [[6]]
    """
    app = Flask(__name__)

    # Configuración de CORS para permitir acceso desde WMS externo [[8]]
    app.config['CORS_HEADERS'] = 'Content-Type'
    cors = CORS(app, resources={r"/*": {"origins": "*"}})

    # Configuración de Swagger [[5]]
    app.config['SWAGGER'] = {
        'title': 'API de Control de Carrusel',
        'uiversion': 3,
        'description': 'API para comunicación con PLC industrial (Modo real/simulador)'
    }
    Swagger(app)

    # Inicializar controlador
    carousel_controller = CarouselController(plc)

    @app.route('/v1/status', methods=['GET'])
    def get_status():
        """
        Obtiene el estado y posición del PLC.
        ---
        tags:
          - Estado del PLC
        responses:
          200:
            description: Estado actual del sistema.
            content:
              application/json:
                schema:
                  type: object
                  properties:
                    status_code:
                      type: integer
                      description: Código de estado (8 bits).
                    position:
                      type: integer
                      description: Posición del carrusel (0-9).
          500:
            description: Error de comunicación.
        """
        if plc.connect():
            try:
                plc.send_command(0)  # Comando STATUS
                time.sleep(0.5)
                response = plc.receive_response()
                return jsonify(response), 200
            except Exception as e:
                return jsonify({'error': f'Error: {str(e)}'}), 500
            finally:
                plc.close()
        else:
            return jsonify({'error': 'No se pudo conectar al PLC'}), 500

    @app.route('/v1/command', methods=['POST'])
    def send_command():
        """
        Envía un comando al PLC.
        ---
        tags:
          - Control del Carrusel
        parameters:
          - in: body
            name: Comando
            required: true
            schema:
              type: object
              properties:
                command:
                  type: integer
                  example: 1
                argument:
                  type: integer
                  example: 3
        responses:
          200:
            description: Comando procesado.
          400:
            description: Parámetros inválidos.
          500:
            description: Error interno.
        """
        if not request.is_json:
            return jsonify({'error': 'Solicitud debe ser JSON'}), 400

        data = request.get_json()
        command = data.get('command')
        argument = data.get('argument')

        if command is None:
            return jsonify({'error': 'Comando no especificado'}), 400

        if not (0 <= command <= 255):
            return jsonify({'error': 'Comando fuera de rango (0-255)'}), 400

        if argument is not None and not (0 <= argument <= 255):
            return jsonify({'error': 'Argumento inválido (0-255)'}), 400

        if plc.connect():
            try:
                carousel_controller.send_command(command, argument)
                return jsonify({'status': 'Comando enviado'}), 200
            except Exception as e:
                return jsonify({'error': f'Error PLC: {str(e)}'}), 500
            finally:
                plc.close()
        else:
            return jsonify({'error': 'No se pudo conectar al PLC'}), 500

    return app


---
Archivo controllers/carousel_controller.py:

"""
Controlador para el carrusel vertical de almacenamiento.

Autor: IA Punto: Soluciones Integrales de Tecnología y Marketing
Proyecto para: INDUSTRIAS PICO S.A.S
Fecha de creación: 2023-09-13
Última modificación: 2024-09-27
"""

from models.plc import PLC  # Importación explícita del PLC real [[2]]
# Interpretación de estados [[3]]
from commons.utils import interpretar_estado_plc
import time
import logging

# Interpretación de estados [[3]]


class CarouselController:
    """
    Controlador para operaciones del carrusel con el PLC.
    """

    def __init__(self, plc: PLC):
        """
        Inicializa el controlador con una instancia de PLC.

        Args:
            plc: Instancia de la clase PLC (real o simulador) [[2]]
        """
        self.plc = plc
        self.logger = logging.getLogger(__name__)

    def send_command(self, command: int, argument: int = None) -> dict:
        """
        Envía un comando al PLC y devuelve la respuesta procesada.

        Args:
            command: Código de comando (0-255)
            argument: Argumento opcional (0-255)

        Returns:
            Diccionario con estado y posición

        Raises:
            ValueError: Parámetros inválidos
            RuntimeError: Error de comunicación
        """
        if not (0 <= command <= 255):
            raise ValueError("Comando fuera de rango (0-255)")

        if argument is not None and not (0 <= argument <= 255):
            raise ValueError("Argumento fuera de rango (0-255)")

        try:
            with self.plc:  # Gestión automática de conexión [[2]]
                self.plc.send_command(command, argument)
                response = self.plc.receive_response()

            # Interpretar estado [[3]]
            status = interpretar_estado_plc(response['status_code'])
            return {
                'status': status,
                'position': response['position'],
                'raw_status': response['status_code']
            }
        except Exception as e:
            self.logger.error(f"Error en send_command: {str(e)}")
            raise RuntimeError(f"Fallo en comunicación PLC: {str(e)}")

    def get_current_status(self) -> dict:
        """
        Obtiene el estado actual del PLC sin enviar comandos.

        Returns:
            Diccionario con estado y posición
        """
        return self.send_command(0)  # Comando 0 = STATUS

    def move_to_position(self, target: int) -> dict:
        """
        Mueve el carrusel a una posición específica.

        Args:
            target: Posición objetivo (0-9)

        Returns:
            Respuesta del PLC
        """
        if not (0 <= target <= 9):
            raise ValueError("Posición debe estar entre 0-9")

        return self.send_command(1, target)  # Comando 1 = MUEVETE

    def verify_ready_state(self) -> bool:
        """
        Verifica si el PLC está listo para operar.

        Returns:
            True si el PLC está en estado READY
        """
        status = self.get_current_status()['status']
        return status.get('READY', '') == 'El equipo está listo para operar'


---
Archivo models/plc.py
"""
Clase PLC para comunicación con PLC Delta AS Series vía sockets TCP/IP.

Autor: IA Punto: Soluciones Integrales de Tecnología y Marketing
Proyecto para: INDUSTRIAS PICO S.A.S
Fecha: 2024-09-27
"""

import socket
import struct
import time

class PLC:
    """
    Encapsula la lógica de comunicación con el PLC Delta AS Series.
    """

    def __init__(self, ip: str, port: int):
        """
        Inicializa el cliente TCP/IP para el PLC.

        Args:
            ip: Dirección IP del PLC (ej: '192.168.1.100').
            port: Puerto de comunicación (típicamente 5000).
        """
        self.ip = ip
        self.port = port
        self.sock = None
        self.timeout = 5.0  # Timeout en segundos [[8]]

    def __enter__(self):
        """Permite uso con 'with' para gestión automática de recursos"""
        self.connect()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        """Cierra conexión al salir del bloque 'with'"""
        self.close()

    def connect(self) -> bool:
        """
        Establece conexión TCP/IP con el PLC.

        Returns:
            True si la conexión es exitosa, False en caso contrario.
        """
        if self.sock:
            return True  # Ya conectado

        try:
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.sock.settimeout(self.timeout)
            self.sock.connect((self.ip, self.port))
            return True
        except (socket.timeout, ConnectionRefusedError) as e:
            print(f"Error de conexión: {str(e)}")
            self.close()
            return False

    def close(self):
        """Cierra la conexión de forma segura"""
        if self.sock:
            try:
                self.sock.shutdown(socket.SHUT_RDWR)
                self.sock.close()
            except OSError:
                pass  # Ignorar errores si ya estaba cerrado
            finally:
                self.sock = None

    def send_command(self, command: int, argument: int = None) -> bool:
        """
        Envía un comando al PLC con formato binario.

        Args:
            command: Entero de 8 bits (0-255).
            argument: Opcional - Entero de 8 bits (0-255).

        Returns:
            True si el envío fue exitoso.

        Raises:
            ValueError: Si los valores están fuera de rango.
            RuntimeError: Si hay error de comunicación.
        """
        if not (0 <= command <= 255):
            raise ValueError("Comando debe ser entre 0-255")

        if argument is not None and not (0 <= argument <= 255):
            raise ValueError("Argumento debe ser entre 0-255")

        if not self.sock:
            raise RuntimeError("No hay conexión activa con el PLC")

        try:
            # Empaquetar comando y argumento en bytes [[3]]
            data = struct.pack('B', command)
            if argument is not None:
                data += struct.pack('B', argument)

            self.sock.sendall(data)
            return True
        except (socket.timeout, BrokenPipeError) as e:
            self.close()
            raise RuntimeError(f"Error enviando datos: {str(e)}")

    def receive_response(self) -> dict:
        """
        Recibe respuesta del PLC (2 bytes: estado y posición).

        Returns:
            Diccionario con 'status_code' y 'position'.

        Raises:
            RuntimeError: Si hay error de recepción.
        """
        if not self.sock:
            raise RuntimeError("No hay conexión activa")

        try:
            # Recibir exactamente 2 bytes [[6]]
            data = self.sock.recv(2)
            if len(data) < 2:
                raise RuntimeError("Respuesta incompleta del PLC")

            status, position = struct.unpack('BB', data)
            return {
                'status_code': status,
                'position': position
            }
        except (socket.timeout, struct.error) as e:
            self.close()
            raise RuntimeError(f"Error recibiendo datos: {str(e)}")

    def get_current_status(self):
        """
        Obtiene el estado actual del PLC.
        Returns:
            dict: Estado del PLC con 'status_code' y 'position'.
        """
        try:
            self.connect()
            self.send_command(0)  # Comando STATUS
            time.sleep(1)  # Espera para recibir la respuesta
            response = self.receive_response()
            return response
        except Exception as e:
            print(f"Error al obtener el estado del PLC: {e}")
            return {"status_code": None, "position": None}


---
Archivo models/plc_simulator.py

"""
Simulador de PLC para desarrollo y pruebas.

Autor: IA Punto: Soluciones Integrales de Tecnología y Marketing
Proyecto para: INDUSTRIAS PICO S.A.S
Fecha: 2024-09-27
"""

import random
import time

class PLCSimulator:
    """
    Simula un PLC con estados y respuestas predefinidas.
    """

    def __init__(self, ip: str, port: int):
        """
        Inicializa el simulador con una dirección IP y puerto ficticios.

        Args:
            ip: Dirección IP ficticia (solo para compatibilidad).
            port: Puerto ficticio (solo para compatibilidad).
        """
        self.ip = ip
        self.port = port
        self.current_position = random.randint(
            0, 9)  # Posición inicial aleatoria
        self.is_running = False  # Estado inicial: detenido
        self.status_code = 0
        self.sock = None  # Simulación de socket

    def connect(self) -> bool:
        """
        Simula la conexión al PLC.

        Returns:
            True si la conexión es exitosa.
        """
        print("Simulando conexión con el PLC...")
        self.sock = type('FakeSocket', (object,), {
            'sendall': self.simulated_sendall,
            '_buffer': b''  # Buffer interno para almacenar datos enviados
        })()
        return True

    def close(self):
        """
        Simula el cierre de la conexión.
        """
        print("Simulando cierre de conexión con el PLC...")
        self.sock = None

    def simulated_sendall(self, data: bytes):
        """
        Simula el envío de datos al PLC.

        Args:
            data: Datos enviados al PLC.
        """
        self.sock._buffer += data
        print(f"Datos simulados enviados al PLC: {data}")

    def send_command(self, command: int, argument: int = None) -> dict:
        """
        Simula el envío de un comando al PLC.

        Args:
            command: Código de comando (0-255).
            argument: Argumento opcional (0-255).

        Returns:
            Diccionario con estado y posición simulados.
        """
        if not (0 <= command <= 255):
            raise ValueError("Comando fuera de rango (0-255)")

        if argument is not None and not (0 <= argument <= 9):
            raise ValueError("Argumento fuera de rango (0-9)")

        try:
            print(
                f"Comando recibido en el simulador: {command}, Argumento: {argument}")
            time.sleep(0.5)  # Simula latencia

            if command == 0:  # Comando STATUS
                self.status_code = self.generate_status()
                position = self.current_position
                print(
                    f"Estado simulado: {self.status_code}, Posición: {position}")
                return {'status_code': self.status_code, 'position': position}

            elif command == 1:  # Comando MUEVETE
                if self.is_running:
                    print("El carrusel ya está en movimiento. Ignorando el comando.")
                    return {'error': 'PLC en movimiento'}

                target_position = argument
                self.is_running = True
                self.status_code |= 0b00000010  # Enciende el bit RUN
                print(
                    f"Moviendo el carrusel a la posición {target_position}...")
                time.sleep(2)  # Simula tiempo de movimiento
                self.current_position = target_position
                self.is_running = False
                self.status_code &= 0b11111101  # Apaga el bit RUN

                return {'status_code': self.status_code, 'position': self.current_position}

            else:
                # Para otros comandos, devuelve estado actual
                self.status_code = self.generate_status()
                return {'status_code': self.status_code, 'position': self.current_position}

        except Exception as e:
            print(f"Error en simulador: {str(e)}")
            return {'error': str(e)}

    def generate_status(self) -> int:
        """
        Genera un código de estado simulado.

        Returns:
            Código de estado simulado (8 bits).
        """
        status_code = random.randint(0, 255)

        # Simula probabilidad de estar en movimiento (30%)
        if random.random() < 0.3:
            self.is_running = True
            status_code |= 0b00000010  # Enciende el bit RUN
        else:
            self.is_running = False
            status_code &= 0b11111101  # Apaga el bit RUN

        # Simula estado READY si no hay errores ni movimiento
        if not self.is_running and (status_code & 0b01111100) == 0:
            status_code |= 0b00000001  # Enciende el bit READY
        else:
            status_code &= 0b11111110  # Apaga el bit READY

        return status_code

    def get_current_status(self) -> dict:
        """
        Obtiene el estado actual del PLC simulado.

        Returns:
            Diccionario con estado y posición simulados.
        """
        self.status_code = self.generate_status()
        return {
            'status_code': self.status_code,
            'position': self.current_position
        }

    def move_to_position(self, target: int) -> dict:
        """
        Mueve el carrusel a una posición específica.

        Args:
            target: Posición objetivo (0-9).

        Returns:
            Respuesta del PLC simulado.
        """
        if not (0 <= target <= 9):
            raise ValueError("Posición debe estar entre 0-9")

        if self.is_running:
            return {'error': 'PLC en movimiento'}

        self.is_running = True
        self.status_code |= 0b00000010  # Enciende el bit RUN
        print(f"Moviendo el carrusel a la posición {target}...")
        time.sleep(2)  # Simula tiempo de movimiento
        self.current_position = target
        self.is_running = False
        self.status_code &= 0b11111101  # Apaga el bit RUN

        return {'status_code': self.status_code, 'position': self.current_position}


---
Archivo gui/main_gui.py

"""
Interfaz gráfica principal para control de carrusel industrial
Autor: IA Punto Soluciones Tecnológicas
Fecha: 2024-09-27

Uso de CustomTkinter para mejorar el aspecto visual.
"""

import os
import sys
import customtkinter as ctk  # Importar CustomTkinter [[1]]
from tkinter import messagebox, simpledialog
import json
import threading
from PIL import Image, ImageTk  # Para manejar imágenes del ícono
import pystray  # Para manejar el área de notificaciones
from commons.utils import interpretar_estado_plc

CONFIG_FILE = "config.json"
DEFAULT_CONFIG = {
    "ip": "192.168.1.100",
    "port": 3200,
    "simulator_enabled": False
}

# Configurar el tema visual de CustomTkinter
ctk.set_appearance_mode("dark")  # Modo oscuro
ctk.set_default_color_theme("dark-blue")  # Tema azul


def resource_path(relative_path):
    """
        Obtiene la ruta absoluta de un recurso, compatible con PyInstaller.
        """
    try:
        # PyInstaller crea una carpeta temporal y almacena los recursos allí
        base_path = sys._MEIPASS
    except Exception:
        base_path = os.path.abspath(".")

    return os.path.join(base_path, relative_path)


class MainWindow:

    def __init__(self, root, plc, config):
        """
        Constructor de la ventana principal.

        Args:
            root: Instancia de CTk()
            plc: Instancia de PLC (real o simulador)
            config: Diccionario con configuración (IP/puerto)
        """
        self.root = root
        self.plc = plc
        self.config = config
        self.root.title("Vertical PIC - Control de Carrusel")
        # Configurar el ícono
        icon_path = resource_path("assets/favicon.ico")
        if os.path.exists(icon_path):
            self.root.iconbitmap(icon_path)
        else:
            print(f"No se encontró el archivo de ícono: {icon_path}")

        self.root.geometry("400x500")

        # Variables de control
        self.ip_var = ctk.StringVar(value=config["ip"])
        self.port_var = ctk.StringVar(value=str(config["port"]))
        self.dev_mode_var = ctk.BooleanVar(value=config.get(
            "simulator_enabled", False))  # Estado del modo desarrollo

        # Variables de control
        # Valor predeterminado para el comando
        self.command_var = ctk.StringVar(value="1")
        # Valor predeterminado para el argumento
        self.argument_var = ctk.StringVar(value="3")

        # Crear el header
        self.create_header()

        # Crear pestañas
        self.create_tabs()

        # Iniciar monitoreo en segundo plano
        self.update_status()

        # Configurar minimización al área de notificaciones
        self.tray_icon = None
        self.root.protocol("WM_DELETE_WINDOW", self.minimize_to_tray)

    def create_header(self):
        """Crea la cabecera con el logo y el botón de salir."""
        header_frame = ctk.CTkFrame(
            self.root, height=180, bg_color="white", corner_radius=0)
        header_frame.pack(fill="x", side="top")

        # Cargar el logo
        logo_path = resource_path("assets/logo.png")
        if os.path.exists(logo_path):
            logo_image = Image.open(logo_path)
            logo_image = logo_image.resize(
                (90, 40), Image.LANCZOS)  # Redimensionar el logo
            logo_tk = ImageTk.PhotoImage(logo_image)
            logo_label = ctk.CTkLabel(
                header_frame, image=logo_tk, text="")
            logo_label.image = logo_tk  # Mantener una referencia para evitar que se elimine
            logo_label.pack(side="left", padx=30, pady=10)
        else:
            print(f"No se encontró el archivo de logo: {logo_path}")

        # Botón de salir
        exit_button = ctk.CTkButton(
            header_frame, text="Salir", command=self.exit_app, fg_color="red", hover_color="darkred", width=80)
        exit_button.pack(side="right", padx=30)

    def send_test_command(self):
        """Envía un comando al PLC para pruebas"""
        try:
            # Obtener valores del formulario
            command = int(self.command_var.get())
            argument = int(self.argument_var.get())

            # Validar los valores
            if not (0 <= command <= 255):
                messagebox.showerror(
                    "Error", "El comando debe estar entre 0 y 255.")
                return

            if not (0 <= argument <= 255):
                messagebox.showerror(
                    "Error", "El argumento debe estar entre 0 y 255.")
                return

            # Conectar al PLC y enviar el comando
            if self.plc.connect():
                try:
                    self.plc.send_command(command, argument)
                    messagebox.showinfo(
                        "Éxito", f"Comando {command} enviado con argumento {argument}.")
                except Exception as e:
                    messagebox.showerror(
                        "Error", f"No se pudo enviar el comando: {str(e)}")
                finally:
                    self.plc.close()
            else:
                messagebox.showerror("Error", "No se pudo conectar al PLC.")
        except ValueError:
            messagebox.showerror(
                "Error", "Los valores deben ser números enteros.")

    def create_exit_button(self):
        """Crea un botón de salida en la interfaz"""
        exit_button = ctk.CTkButton(
            self.root, text="Salir", command=self.exit_app, fg_color="red", hover_color="darkred")
        exit_button.pack(side="bottom", pady=10)

    def minimize_to_tray(self):
        """Minimiza la ventana al área de notificaciones."""
        self.root.withdraw()  # Oculta la ventana principal

        # Crear un ícono para la bandeja del sistema
        # Reemplaza "icon.png" con tu ícono
        image = resource_path("assets/favicon.ico")
        icon = Image.open(image)
        menu = pystray.Menu(
            pystray.MenuItem('Restaurar', self.restore_window),
            pystray.MenuItem('Salir', self.exit_app)
        )
        self.tray_icon = pystray.Icon(
            "favicon", icon, "Vertical PIC", menu)
        self.tray_icon.run()

    def restore_window(self):
        """Restaura la ventana desde la bandeja del sistema."""
        if self.tray_icon:
            self.tray_icon.stop()  # Detiene el ícono de la bandeja
        self.root.deiconify()  # Muestra la ventana principal

    def exit_app(self):
        """Cierra la aplicación."""
        if self.tray_icon:
            self.tray_icon.stop()
        self.root.quit()

    def create_tabs(self):
        """Crea las pestañas para la interfaz"""
        tab_view = ctk.CTkTabview(self.root, width=780, height=500)
        tab_view.pack(padx=10, pady=10)

        # Pestaña 1: Estado del PLC
        tab_estado = tab_view.add("Estado del PLC")
        self.create_estado_frame(tab_estado)

        # Pestaña 2: Enviar Comandos
        tab_comandos = tab_view.add("Enviar Comandos")
        self.create_command_frame(tab_comandos)

        # Pestaña 3: Configuración
        tab_config = tab_view.add("Configuración")
        self.create_config_frame(tab_config)

    def create_command_frame(self, parent):
        """Crea la pestaña para enviar comandos al PLC."""
        command_frame = ctk.CTkFrame(parent, corner_radius=10)
        command_frame.pack(padx=10, pady=10, fill="both", expand=True)

        # Campo para el comando
        ctk.CTkLabel(command_frame, text="Comando:").grid(
            row=0, column=0, padx=5, pady=5, sticky="w")
        ctk.CTkEntry(command_frame, textvariable=self.command_var,
                     width=50).grid(row=0, column=1, padx=5, pady=5)

        # Campo para el argumento
        ctk.CTkLabel(command_frame, text="Argumento:").grid(
            row=1, column=0, padx=5, pady=5, sticky="w")
        ctk.CTkEntry(command_frame, textvariable=self.argument_var,
                     width=50).grid(row=1, column=1, padx=5, pady=5)

        # Botón Enviar
        send_button = ctk.CTkButton(
            command_frame, text="Enviar", command=self.send_test_command, fg_color="green", hover_color="darkgreen")
        send_button.grid(row=2, column=0, columnspan=2, pady=10)

    def create_estado_frame(self, parent):
        """Frame para mostrar el estado del PLC"""
        status_frame = ctk.CTkFrame(parent, corner_radius=10)
        status_frame.pack(padx=10, pady=10, fill="both", expand=True)

        # Título
        title_label = ctk.CTkLabel(
            status_frame, text="Estado del Sistema", font=("Arial", 14, "bold"))
        title_label.grid(row=0, column=0, columnspan=2,
                         pady=(5, 10), sticky="w")

        # Etiquetas de estado
        self.status_labels = {}
        row = 1
        for key in ["READY", "RUN", "MODO_OPERACION", "ALARMA", "PARADA_EMERGENCIA", "VFD", "ERROR_POSICIONAMIENTO"]:
            label_key = ctk.CTkLabel(
                status_frame, text=f"{key}:", font=("Arial", 12))
            label_key.grid(row=row, column=0, padx=10, pady=5, sticky="w")

            label_value = ctk.CTkLabel(
                status_frame, text="---", font=("Arial", 12))
            label_value.grid(row=row, column=1, padx=10, pady=5, sticky="w")

            self.status_labels[key] = label_value
            row += 1

        # Posición actual
        pos_label_key = ctk.CTkLabel(
            status_frame, text="POSICIÓN ACTUAL:", font=("Arial", 12))
        pos_label_key.grid(row=row, column=0, padx=10, pady=5, sticky="w")

        self.position_label = ctk.CTkLabel(
            status_frame, text="---", font=("Arial", 12))
        self.position_label.grid(
            row=row, column=1, padx=10, pady=5, sticky="w")

    def update_status(self):
        """Actualiza el estado del PLC en la GUI."""
        try:
            status_data = self.plc.get_current_status()

            if status_data["status_code"] is None or status_data["position"] is None:
                print("No se recibió respuesta válida del PLC.")
                return

            # Interpretar estado
            interpreted_status = interpretar_estado_plc(
                status_data['status_code'])

            # Actualizar etiquetas
            for key, label in self.status_labels.items():
                value = interpreted_status.get(key, "Desconocido")
                label.configure(text=value)

        except Exception as e:
            print(f"Error al actualizar estado: {str(e)}")

        # Programar próxima actualización
        self.root.after(3000, self.update_status)

    def create_config_frame(self, parent):
        """Frame para configuración de IP, puerto y modo"""
        config_frame = ctk.CTkFrame(parent, corner_radius=10)
        config_frame.pack(padx=10, pady=10, fill="both", expand=True)

        # Título
        title_label = ctk.CTkLabel(
            config_frame, text="Configuración del Sistema", font=("Arial", 14, "bold"))
        title_label.grid(row=0, column=0, columnspan=2,
                         pady=(5, 10), sticky="w")

        # IP
        ctk.CTkLabel(config_frame, text="IP PLC:").grid(
            row=1, column=0, padx=5, pady=5)
        ctk.CTkEntry(config_frame, textvariable=self.ip_var,
                     width=150).grid(row=1, column=1)

        # Puerto PLC
        ctk.CTkLabel(config_frame, text="Puerto PLC:").grid(
            row=2, column=0, padx=5, pady=5)
        ctk.CTkEntry(config_frame, textvariable=self.port_var,
                     width=50).grid(row=2, column=1)

        # Puerto API
        # Puerto predeterminado para la API
        self.api_port_var = ctk.StringVar(value=str(5001))
        ctk.CTkLabel(config_frame, text="Puerto API:").grid(
            row=3, column=0, padx=5, pady=5)
        ctk.CTkEntry(config_frame, textvariable=self.api_port_var,
                     width=50).grid(row=3, column=1)

        # Modo Desarrollo/Producción
        ctk.CTkCheckBox(config_frame, text="Modo Simulador", variable=self.dev_mode_var,
                        command=self.toggle_development_mode).grid(row=4, column=0, columnspan=2, pady=10)

        # Botón Guardar
        ctk.CTkButton(config_frame, text="Guardar", command=self.save_config).grid(
            row=5, column=0, columnspan=2, pady=10)

    def save_config(self):
        """Guarda la configuración IP/puerto en config.json"""
        try:
            new_config = {
                "ip": self.ip_var.get(),
                "port": int(self.port_var.get()),
                # Guarda el puerto de la API
                "api_port": int(self.api_port_var.get()),
                "simulator_enabled": self.dev_mode_var.get()
            }
            with open(CONFIG_FILE, 'w') as f:
                json.dump(new_config, f)
            messagebox.showinfo("Éxito", "Configuración guardada")
        except ValueError:
            messagebox.showerror("Error", "Puerto inválido")

    def toggle_development_mode(self):
        """Activa o desactiva el modo simulador"""
        if self.dev_mode_var.get():
            password = simpledialog.askstring(
                "Validación", "Ingrese la contraseña de desarrollo:", show='*')
            if password != "DESARROLLO123":
                messagebox.showerror("Error", "Contraseña incorrecta")
                self.dev_mode_var.set(False)
                return

            from models.plc_simulator import PLCSimulator
            self.plc = PLCSimulator(self.config["ip"], self.config["port"])
            messagebox.showinfo("Modo Desarrollo", "Modo simulador activado")
        else:
            from models.plc import PLC
            self.plc = PLC(self.config["ip"], self.config["port"])
            messagebox.showinfo("Modo Producción",
                                "Conexión con PLC real restaurada")

        self.config["simulator_enabled"] = self.dev_mode_var.get()
        with open(CONFIG_FILE, 'w') as f:
            json.dump(self.config, f)


---
Archivo commons/utils.py

# utils.py

ESTADOS_PLC = {
    "READY": {
        "bit": 0,
        "descripcion": {
            0: "El equipo no puede operar",
            1: "El equipo está listo para operar"
        }
    },
    "RUN": {
        "bit": 1,
        "descripcion": {
            0: "El equipo está detenido",
            1: "El equipo está en movimiento (comando de movimiento activo)"
        }
    },
    "MODO_OPERACION": {
        "bit": 2,
        "descripcion": {
            0: "Modo Remoto",
            1: "Modo Manual"
        }
    },
    "ALARMA": {
        "bit": 3,
        "descripcion": {
            0: "No hay alarma",
            1: "Alarma activa"
        }
    },
    "PARADA_EMERGENCIA": {
        "bit": 4,
        "descripcion": {
            0: "Sin parada de emergencia",
            1: "Parada de emergencia presionada y activa"
        }
    },
    "VFD": {
        "bit": 5,
        "descripcion": {
            0: "El variador de velocidad está OK",
            1: "Error en el variador de velocidad"
        }
    },
    "ERROR_POSICIONAMIENTO": {
        "bit": 6,
        "descripcion": {
            0: "No hay error de posicionamiento",
            1: "Ha ocurrido un error en el posicionamiento"
        }
    },
    "SENTIDO_GIRO": {
        "bit": 7,
        "descripcion": {
            0: "Ascendente",
            1: "Descendente"
        }
    }
}


def interpretar_estado_plc(status_code):
    """
    Interpreta el código de estado del PLC y devuelve un diccionario con los estados y sus descripciones específicas.

    Args:
        status_code: El código de estado del PLC en formato entero (8 bits).

    Returns:
        Un diccionario donde las claves son los nombres de los estados y los valores son sus descripciones específicas.
    """
    estados_activos = {}

    # Iterar sobre todos los estados definidos en ESTADOS_PLC
    for estado, detalles in ESTADOS_PLC.items():
        bit = detalles["bit"]
        # Extraer el valor del bit correspondiente
        valor_bit = (status_code >> bit) & 1
        # Obtener la descripción específica del estado basada en el valor del bit
        estados_activos[estado] = detalles["descripcion"][valor_bit]

    return estados_activos
